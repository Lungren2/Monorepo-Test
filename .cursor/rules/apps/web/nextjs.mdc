---
description: Apply these guidelines when building a NextJS project
alwaysApply: false
---

A focused rule set for Cursor to implement and review code so our Next.js app stays fast on a **self‑hosted Node server** with an external **ASP.NET** backend. Treat this as a living spec.

---

# Scope & Priorities

* **Targets**: Next.js App Router (v14/15+), self‑hosted (Node, Docker, or similar), optional reverse proxy/CDN (Nginx/Traefik/Cloudflare/etc.).
* **Performance hierarchy**: (1) Ship less JS → (2) Stream/PPR early UI → (3) Cache correctly → (4) Invalidate precisely → (5) Put a proxy cache in front of static/optimized assets → (6) Measure.
* **Default stance**: Prefer **Server Components** and **static/streamed** delivery. Avoid client JS unless interactivity demands it.

---

## 1) Rendering & Routing

**1.1 Server Components by default**

* Pages/layouts/components are Server Components unless the browser is required. Keep any `"use client"` islands small.

**1.2 Partial Prerendering (PPR) & Streaming**

* Structure routes so the **shell** and stable content render statically; wrap slow/personalized sections in `<Suspense>` and stream them once ready.
* Provide `app/**/loading.tsx` for segments that fetch data.
* Avoid `cookies()`, `headers()`, or direct `searchParams` usage in the static shell; isolate such reads behind Suspense or move them to a Route Handler (BFF).

**1.3 Segment configuration**

```ts
// app/(marketing)/page.tsx
export const dynamic = 'force-static'; // fully static where possible
export const revalidate = 3600; // or per‑segment revalidation
```

Only use `force-dynamic` when absolutely necessary (e.g., per‑request auth UI).

**1.4 Enabling PPR**

```ts
// next.config.ts
export default {
  experimental: { ppr: 'incremental' }
};

// app/(shop)/layout.tsx
export const experimental_ppr = true; // opt‑in per route
```

---

## 2) Data Fetching & Caching (App Router)

**2.1 Fetch defaults**

* Fetches are uncached by default—opt into caching explicitly:

```ts
await fetch(url, { cache: 'force-cache' });
await fetch(url, { next: { revalidate: 60 } }); // time‑based
```

**2.2 Tag‑based revalidation**

* Tag related fetches and revalidate them on mutations/webhooks:

```ts
// read
await fetch(url, { next: { tags: ['products:list'] } });

// on write (Server Action or Route Handler)
import { revalidateTag, revalidatePath } from 'next/cache';
await revalidateTag('products:list');
await revalidatePath('/products');
```

Prefer **tags** for granular freshness; use **path** for page‑level refresh.

**2.3 Self‑hosted cache note**

* In single‑instance setups, Next’s default cache is fine. For **multiple instances/containers**, configure a **shared cache handler** so tags propagate cluster‑wide (see §4.3).

---

## 3) BFF Layer (Route Handlers) for the ASP.NET API

> Use Route Handlers under `app/api/*` as a **Backend‑for‑Frontend (BFF)**

**3.1 Pattern**

```ts
// app/api/products/route.ts (Node runtime)
export const runtime = 'node';

export async function GET() {
  const res = await fetch(`${process.env.API_BASE}/products`, {
    headers: { Authorization: `Bearer ${/* token source */''}` },
    // If you rely on browser cookies → BFF, ensure client uses credentials: 'include'
  });

  // Cache at your reverse proxy/CDN per §4; keep browser cache conservative
  return new Response(await res.text(), {
    status: res.status,
    headers: {
      'Content-Type': res.headers.get('content-type') ?? 'application/json',
      'Cache-Control': 'public, max-age=0, s-maxage=600',
    },
  });
}
```

**3.2 Credentials & cookies**

* Browser → BFF: `fetch(url, { credentials: 'include' })` when cookie auth is used.
* Prefer token forwarding from the BFF to ASP.NET over exposing cross‑site cookies.

**3.3 Invalidation**

* On successful mutations (via BFF or Server Actions), call `revalidateTag()` / `revalidatePath()`.

---

## 4) Reverse Proxy/CDN Caching & Dynamic Pitfalls

**4.1 Be explicit**

* Control caching with **Cache-Control** in BFF responses. For shared caches, use `public, max-age=0, s-maxage=<seconds>`.
* Don’t cache HTML that depends on cookies/headers. Reserve proxy/CDN caching for immutable build assets and optimized images.

**4.2 Reverse proxy basics (self‑hosted)**

* Ensure your proxy (Nginx/Traefik/HAProxy/Cloudflare/etc.) respects `Cache-Control` and avoids caching HTML that varies per user.
* Keep app‑level HTML caching inside Next.js (ISR/Data Cache). Use the proxy mainly for static and image endpoints (e.g., `/_next/static`, `/_next/image`).

**4.3 Shared Data Cache for multi‑instance**

* `revalidateTag`/`revalidatePath` work out of the box, but for **distributed** deployments configure a **custom cache handler** so invalidations reach every node.

```js
// next.config.js
module.exports = {
  cacheHandler: require.resolve('./cache-handler.js'),
  cacheMaxMemorySize: 0, // disable per‑instance memory cache for consistency
}

// cache-handler.js (skeleton)
class CacheHandler {
  constructor(options) { /* connect to Redis/Memcached/etc. */ }
  async get(key) { /* return cached value */ }
  async set(key, data, ctx) { /* store value + ctx.tags + ctx.revalidate */ }
  async revalidateTag(tagOrTags) { /* delete entries matching tag(s) */ }
  resetRequestCache() {}
}
module.exports = CacheHandler;
```

* Tag everything you’ll need to invalidate together (e.g., `product:123`, `collection:summer-2025`).

**4.4 Dynamic triggers**

* Using `cookies()`, `headers()`, or `searchParams` in a page/layout forces dynamic rendering. Keep these in Route Handlers or isolate behind Suspense.

---

## 5) Images

**5.1 Use `<Image />` and configure sources**

```js
// next.config.js
module.exports = {
  images: {
    remotePatterns: [
      { protocol: 'https', hostname: 'images.example.com' },
      { protocol: 'https', hostname: 'cdn.myapp.com' },
    ],
    formats: ['image/webp'],
    minimumCacheTTL: 60,
  },
};
```

* Use correct `sizes` and dimensions. Mark the LCP image `priority`.
* If doing a **static export** (`output: 'export'`), the built‑in Image Optimization API is unavailable. Either run the Node server or use a custom loader/export‑time optimizer.

---

## 6) ASP.NET Backend Integration (CORS & Cookies)

**6.1 CORS (server)**

```csharp
builder.Services.AddCors(o => o.AddPolicy("WebApp", policy =>
  policy.WithOrigins("https://app.example.com")
        .AllowAnyHeader()
        .AllowAnyMethod()
        .AllowCredentials()
));
app.UseCors("WebApp");
```

* Don’t combine wildcard origins with credentials. Use explicit allow‑lists.

**6.2 Cookies (cross‑site)**

```csharp
options.Cookie.SameSite = SameSiteMode.None;
options.Cookie.SecurePolicy = CookieSecurePolicy.Always;
```

* Browser fetches that rely on cookies must set `credentials: 'include'`.

---

## 7) Observability & Budgets

* Track Core Web Vitals (LCP/CLS/INP). Use the `web-vitals` package or your analytics of choice; keep JS bundles lean.
* No heavy UI libs in Server Components; prefer CSS and native elements.
* Add CI checks to block regressions (e.g., bundle size warnings from `next build`).

---

## 8) Ready‑to‑Paste Snippets

**8.1 Fetch with tags + timeout**

```ts
async function fetchJSON(input: RequestInfo, init: RequestInit & { tags?: string[]; revalidate?: number } = {}) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), 8000);
  try {
    const res = await fetch(input, {
      ...init,
      next: { revalidate: init.revalidate, tags: init.tags },
      signal: controller.signal,
    });
    if (!res.ok) throw new Error(`Fetch failed: ${res.status}`);
    return await res.json();
  } finally {
    clearTimeout(id);
  }
}
```

**8.2 Server Action with precise revalidation**

```ts
'use server';
import { revalidateTag } from 'next/cache';

export async function updateProduct(id: string, patch: any) {
  // call BFF → ASP.NET here
  await revalidateTag('products:list');
}
```

**8.3 BFF route with proxy‑cache friendly headers**

```ts
// app/api/search/route.ts
export async function GET(req: Request) {
  const url = new URL(req.url);
  const q = url.searchParams.get('q') ?? '';
  const upstream = await fetch(`${process.env.API_BASE}/search?q=${encodeURIComponent(q)}`, {
    headers: { 'Accept': 'application/json' },
  });
  return new Response(upstream.body, {
    status: upstream.status,
    headers: {
      'Content-Type': upstream.headers.get('content-type') ?? 'application/json',
      'Cache-Control': 'public, max-age=0, s-maxage=300',
    },
  });
}
```

**8.4 Suspense boundary for slow widgets**

```tsx
// app/dashboard/page.tsx
import { Suspense } from 'react';
import { KPICards } from './_components/kpi-cards';
import { RevenueChart } from './_components/revenue-chart';

export const dynamic = 'force-static'; // shell stays static

export default function Page() {
  return (
    <div>
      <KPICards />
      <Suspense fallback={<div className="skeleton h-64" />}>
        <RevenueChart />
      </Suspense>
    </div>
  );
}
```

---

## 9) Code Review Checklist (Cursor should enforce)

* [ ] Server‑first (no unnecessary `"use client"`).
* [ ] Slow sections behind `<Suspense>` + `loading.tsx` for dynamic segments.
* [ ] Fetches use `cache: 'force-cache'`/`next.revalidate` and **tags** for precise invalidation.
* [ ] Mutations trigger `revalidateTag`/`revalidatePath`.
* [ ] Route Handlers act as the BFF to the ASP.NET API; responses have cache headers suitable for a proxy.
* [ ] Dynamic APIs (cookies/headers/searchParams) avoided in static shells or isolated to islands.
* [ ] Images via `<Image />` with vetted `remotePatterns`; LCP image `priority`.
* [ ] CORS configured with explicit origins + credentials (where needed); cookies use `SameSite=None; Secure` for cross‑site scenarios.
* [ ] For multi‑instance hosting, a **shared cache handler** is configured and documented.

---

**Keep it lean. Stream what’s slow. Cache smart. Invalidate precisely.**
