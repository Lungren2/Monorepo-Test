---
description: Best practices for scaffolding/creating endpoints in the API
globs: ["**/*Endpoint.cs", "apps/api/Endpoints/**/*.cs"]
alwaysApply: false
contextPriority: high
relatedRules: ["api-general-guidelines", "dependencies/dotnet-best-practices", "domain-modeling"]
keywords: ["fastendpoints", "endpoints", "api", "send-async", "validation"]
lastUpdated: "2025-01-03"
---

# FastEndpoints Changelog & Upgrade Guide (since v7.0.1)

---

## 1. Dropped support for .NET 6 & 7

**What changed:**
FastEndpoints now requires **.NET ≥ 8.0.4**.

**Impact:**
Projects targeting `.NET 6` or `.NET 7` will not build.

**Upgrade path:**
Update your `TargetFramework` in `.csproj`:

```xml
<!-- Old -->
<TargetFramework>net7.0</TargetFramework>

<!-- New -->
<TargetFramework>net8.0</TargetFramework>
```

Also ensure SDK/runtime is installed:

```bash
dotnet --list-sdks
```

---

## 2. Response sending APIs → `Send.*Async` pattern

**What changed:**
The **response methods** have been streamlined to `Send.OkAsync(...)`, `Send.NotFoundAsync(...)`, etc.
They also auto-wire the `CancellationToken` from `HandleAsync`.

**Before (7.0.1):**

```csharp
await SendAsync(response, cancellation: ct);
await SendErrorsAsync(400, validationErrors, ct);
```

**Now (≥ 8):**

```csharp
await Send.OkAsync(response);       // auto uses ct
await Send.ErrorsAsync(statusCode: 400);
```

**Why:**
Cleaner, less noise, consistent with `Ok`, `NotFound`, `Errors`.

**Migration check:**
Search for `SendAsync` or `SendErrorsAsync` in your project and replace with new `Send.*Async`.

---

## 3. Binding rules with `required` keyword

**What changed:**
When mixing multiple binding sources (`[FromQuery]`, `[FromBody]`, `[FromHeader]`), the `required` keyword has stricter enforcement.

**Before (7.0.1):**

```csharp
public sealed class MyRequest
{
    [FromQuery] public string? Id { get; set; }   // null if missing
}
```

A missing `Id` might silently pass with `null`.

**Now:**

```csharp
public sealed class MyRequest
{
    [FromQuery] public required string Id { get; set; }
}
```

If `Id` is missing → automatic validation error, `400 Bad Request`.

**Migration check:**
Audit DTOs with `required` fields. If your clients sometimes omit them, update contracts or relax validation.

Docs: [Model Binding](https://fast-endpoints.com/docs/model-binding)

---

## 4. Server-Sent Events (SSE) streaming

**What changed:**
Handling of multiple SSE models in a single stream has been modified.

**Before (7.0.1):**

```csharp
await SendEventAsync(new { Message = "Step1" });
await SendEventAsync(new { Message = "Step2" });
```

May have been buffered differently.

**Now (≥ 8):**
FastEndpoints ensures proper *flushing & framing* so each SSE is a distinct event.

**Migration check:**
Test clients that rely on SSE to confirm they still process multiple events correctly.

Docs: [Server-Sent Events](https://fast-endpoints.com/docs/server-sent-events)

---

## 5. Swagger / OpenAPI generation fixes

**What changed:**
Examples and schemas now generate more accurately, especially with `[FromBody]`, `[FromForm]`, and headers.

**Before (7.0.1):**

* Swagger might show wrong schema for form-bound DTOs.
* XML docs for properties sometimes missing in OpenAPI.

**Now (≥ 8):**

* Correct examples and schema.
* Better header support.

**Migration check:**
If you ship SDKs/clients based on OpenAPI, regenerate them — schema may differ.

Docs: [Swagger Support](https://fast-endpoints.com/docs/swagger-support)

---

## 6. Exception handler MIME type fix

**What changed:**
Default exception handler now sends the correct `Content-Type`.

**Before (buggy):**

```
Content-Type: text/plain
```

**Now (fixed):**

```
Content-Type: application/problem+json
```

**Migration check:**
Clients expecting `text/plain` need adjusting.

Docs: [Exception Handler](https://fast-endpoints.com/docs/exception-handler)

---

## 7. Misc improvements

* **Malformed JSON arrays** can now bind successfully.
* **Query parameters inference** improved for integration testing.
* **Event Bus & Command Bus** got bug fixes for reliability.
* **Job Queues**: progress reporting and result tracking improved.

Docs:

* [Event Bus](https://fast-endpoints.com/docs/event-bus)
* [Command Bus](https://fast-endpoints.com/docs/command-bus)
* [Job Queues](https://fast-endpoints.com/docs/job-queues)

---

Here’s a tight, copy-pasteable **refactor cheat-sheet** for moving from legacy `Send*` calls (around 7.0.1) to the modern **`Send.*Async` pattern**—with side-by-side diffs, working examples, and quick tests to confirm behavior.

---


## Diff table — legacy vs. current `Send.*Async`

> Scope: only mappings that are **documented & stable** in the current pattern. Avoids guessing additional helpers.
> The new methods implicitly use the `CancellationToken` from `HandleAsync`, so you don’t need to pass `ct`.&#x20;

| Intent                                      | Legacy (≤ \~7.x)                                                                             | Current (≥ new pattern)                                                                  |
| ------------------------------------------- | -------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| 200 OK with body                            | `await SendAsync(dto, cancellation: ct);`                                                    | `await Send.OkAsync(dto);`                                                               |
| Validation / error response (e.g., 400/409) | `await SendErrorsAsync(400, failures, ct);` or `await SendErrorsAsync(statusCode: 409, ct);` | `await Send.ErrorsAsync(statusCode: 400);` or `await Send.ErrorsAsync(statusCode: 409);` |

**Notes**

* The **Send.\*Async** shape is the recommended, cleaner pattern going forward (auto-uses the same request token).
* If you truly need a *different* token (e.g., timeout), you can pass it explicitly, but that’s the exception, not the norm.

---

## Minimal snippets (compile-ready)

### 1) Program.cs (baseline)

```csharp
// Program.cs (.NET 9, top-level)
using FastEndpoints;
using FastEndpoints.Swagger;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddFastEndpoints();
builder.Services.AddSwaggerDoc();

var app = builder.Build();

app.UseFastEndpoints();
app.UseOpenApi();
app.UseSwaggerUi3(s => s.ConfigureDefaults());

app.Run();
```

Why: standard FastEndpoints bootstrap + Swagger for quick manual checks.
Docs: Swagger Support, Configuration Settings.&#x20;

### 2) Endpoint: 200 OK with body (old → new)

**Before**

```csharp
using FastEndpoints;

public sealed class GetThingEndpoint_Old : EndpointWithoutRequest<ThingDto>
{
    public override void Configure() => Get("/things/{id}");

    public override async Task HandleAsync(CancellationToken ct)
    {
        var dto = new ThingDto { Id = "123", Name = "Widget" };
        await SendAsync(dto, cancellation: ct);
    }
}

public sealed class ThingDto { public string Id { get; set; } = default!; public string Name { get; set; } = default!; }
```

**After**

```csharp
using FastEndpoints;

public sealed class GetThingEndpoint : EndpointWithoutRequest<ThingDto>
{
    public override void Configure() => Get("/things/{id}");

    public override async Task HandleAsync(CancellationToken ct)
    {
        var dto = new ThingDto { Id = "123", Name = "Widget" };
        await Send.OkAsync(dto); // auto-uses the same ct internally
    }
}

public sealed class ThingDto { public string Id { get; set; } = default!; public string Name { get; set; } = default!; }
```

Why: new pattern is explicit about intent (`Ok`) and auto-wires the token.
Docs: Misc Conveniences (pattern evolution), Integration & Unit Testing (to verify).&#x20;

### 3) Endpoint: errors / validation failure (old → new)

**Before**

```csharp
using FastEndpoints;

public sealed class CreateThingEndpoint_Old : Endpoint<ThingCreateReq, EmptyResponse>
{
    public override void Configure() => Post("/things");

    public override async Task HandleAsync(ThingCreateReq req, CancellationToken ct)
    {
        if (string.IsNullOrWhiteSpace(req.Name))
        {
            AddError(nameof(req.Name), "Name is required.");
            await SendErrorsAsync(400, ct);
            return;
        }

        await SendAsync(new EmptyResponse(), cancellation: ct); // or some created/ok pattern
    }
}

public sealed class ThingCreateReq { public string? Name { get; set; } }
```

**After**

```csharp
using FastEndpoints;

public sealed class CreateThingEndpoint : Endpoint<ThingCreateReq, EmptyResponse>
{
    public override void Configure() => Post("/things");

    public override async Task HandleAsync(ThingCreateReq req, CancellationToken ct)
    {
        if (string.IsNullOrWhiteSpace(req.Name))
        {
            AddError(nameof(req.Name), "Name is required.");
            await Send.ErrorsAsync(statusCode: 400);
            return;
        }

        await Send.OkAsync(new EmptyResponse());
    }
}

public sealed class ThingCreateReq { public string? Name { get; set; } }
```

Why: `Send.ErrorsAsync(statusCode: …)` is the canonical error path; token flows automatically.
Docs: Validation, Exception Handler (error response shape), Integration & Unit Testing.&#x20;

---

## Quick confirmations (tests you can run)

> Using the lightweight, routeless testing style from the docs to assert status codes & bodies.
> Docs: Integration & Unit Testing.&#x20;

### OK response

```csharp
using FastEndpoints;
using System.Net;
using System.Net.Http.Json;
using Xunit;

public class OkTests
{
    [Fact]
    public async Task returns_ok_with_body()
    {
        using var app = Factory.Create<Program>();
        var client = app.CreateClient();

        var res = await client.GetAsync("/things/123");
        Assert.Equal(HttpStatusCode.OK, res.StatusCode);

        var dto = await res.Content.ReadFromJsonAsync<ThingDto>();
        Assert.Equal("123", dto!.Id);
        Assert.Equal("Widget", dto!.Name);
    }
}
```

### Error response

```csharp
using FastEndpoints;
using System.Net;
using System.Net.Http.Json;
using Xunit;

public class ErrorTests
{
    [Fact]
    public async Task returns_400_with_problem_details()
    {
        using var app = Factory.Create<Program>();
        var client = app.CreateClient();

        var res = await client.PostAsJsonAsync("/things", new { Name = "" });

        Assert.Equal(HttpStatusCode.BadRequest, res.StatusCode);
        Assert.Equal("application/problem+json", res.Content.Headers.ContentType!.MediaType); // default problem-details
    }
}
```

Why: proves `Send.OkAsync` returns a body with 200, and `Send.ErrorsAsync(400)` yields RFC7807 problem details by default (good client-compat behavior). Docs: Exception Handler, Integration & Unit Testing.&#x20;

---

## Checklist

* Replace legacy calls with the mapped **`Send.*Async`** equivalents above.
* Do **not** pass `ct` unless you intentionally want a different token.
* Assert error responses parse as **problem+json** (clients/parsers updated).
* Re-run integration tests; confirm schemas & status codes.
* Keep DTO validation in validators where possible; use `AddError(...)` sparingly. Docs: Validation.&#x20;

---

## Doc anchors (official)

* Validation — [https://fast-endpoints.com/docs/validation](https://fast-endpoints.com/docs/validation)
* Exception Handler — [https://fast-endpoints.com/docs/exception-handler](https://fast-endpoints.com/docs/exception-handler)
* Integration & Unit Testing — [https://fast-endpoints.com/docs/integration-unit-testing](https://fast-endpoints.com/docs/integration-unit-testing)
* Swagger Support (optional) — [https://fast-endpoints.com/docs/swagger-support](https://fast-endpoints.com/docs/swagger-support)
* Misc Conveniences — [https://fast-endpoints.com/docs/misc-conveniences](https://fast-endpoints.com/docs/misc-conveniences)

